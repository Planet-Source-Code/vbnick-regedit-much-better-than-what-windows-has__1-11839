Attribute VB_Name = "ODBC_Management"
' Assorted functions for manipulating ODBC
'Code totaly generated by looking at other samples On internet,by Kayhan Tanriseven
'   Notes:
' These wrapper functions are direct functional wrappers for the existing API functions
' Their purpose is to make the data types easier to work with under VB
' Please don't use the API functions directly, as this is a perennial source of obscure VB bugs
'
' When extending this module, don't place any sophisticated code in here
' - use Registry.BAS instead for higher level functions.
'
' This code makes no attempt to support multiple platforms.
' It's enough work to get it running under plain '95 for starters !
'

'
Option Explicit



' Where a user's ODBC sources are stored
Public Const mODBCkeyName = "Software\ODBC\ODBC.INI\"
' Where the settings for ODBC are stored
Public Const mODBCDriverkeyName = "Software\ODBC\ODBCINST.INI\"

' Creates an ODBC data source by manipulating the Registry
'
'   Enhancements:
'
' Be smarter about selecting the default language
'
Public Function CreateODBCDataSource(pDSN$, pServerType$, pServer$, pDatabase$, pDescription$) As Long

Dim llRetVal As Long, llMinorRetVal As Long
Dim lhODBCKey As Long
Dim lhOurKey As Long
Dim lSQLDriver$



  llRetVal = -1
  
  ' Validity checks
  CreateODBCDataSource = llRetVal
  If False Then Exit Function
  
  
  ' Find the SQL server driver to use
  llRetVal = RegOpenKey(HKEY_LOCAL_MACHINE, mODBCDriverkeyName & pServerType$, KEY_WRITE, lhODBCKey)
  If (llRetVal = ERROR_SUCCESS) Then llRetVal = RegQueryValue(lhODBCKey, "Driver", lSQLDriver$)
  If (llRetVal = ERROR_SUCCESS) Then If (Len(lSQLDriver$) = 0) Then llRetVal = -1
  
  ' Try to obtain a key to the ODBC sources list
  If (llRetVal = ERROR_SUCCESS) Then llRetVal = RegOpenKey(HKEY_CURRENT_USER, mODBCkeyName & "ODBC Data Sources", KEY_WRITE, lhODBCKey)
    
  ' Make an entry under the key:
  If (llRetVal = ERROR_SUCCESS) Then llRetVal = RegCreateKey(HKEY_CURRENT_USER, mODBCkeyName & pDSN$, lhOurKey)
 
  ' Insert our values
  If (llRetVal = ERROR_SUCCESS) Then
    llRetVal = RegSetValue(lhOurKey, "Database", REG_SZ, pDatabase$)
    If (llRetVal = ERROR_SUCCESS) Then
      If (Len(pDescription$) > 0) Then llRetVal = RegSetValue(lhOurKey, "Description", REG_SZ, pDescription$)
    End If
    If (llRetVal = ERROR_SUCCESS) Then llRetVal = RegSetValue(lhOurKey, "Driver", REG_SZ, lSQLDriver$)
    If (llRetVal = ERROR_SUCCESS) Then llRetVal = RegSetValue(lhOurKey, "FastConnectOption", REG_SZ, "Yes")
    ' KLUDGE - Should be smarter about selecting language - It isn't essential to set it anyway
    ' If (llRetVal = ERROR_SUCCESS) Then llRetVal = RegSetValue(lhOurKey, "Language", REG_SZ, "us_english")
    If (llRetVal = ERROR_SUCCESS) Then llRetVal = RegSetValue(lhOurKey, "OEMTOANSI", REG_SZ, "Yes")
    If (llRetVal = ERROR_SUCCESS) Then llRetVal = RegSetValue(lhOurKey, "Server", REG_SZ, pServer$)
    If (llRetVal = ERROR_SUCCESS) Then llRetVal = RegSetValue(lhOurKey, "UseProcForPrepare", REG_SZ, "Yes")
    llMinorRetVal = RegCloseKey(lhOurKey)
    If (llRetVal = ERROR_SUCCESS) Then llRetVal = llMinorRetVal
  End If
  
  ' Record the entry in our list under
  If (llRetVal = ERROR_SUCCESS) Then llRetVal = RegSetValue(lhODBCKey, pDSN$, REG_SZ, ByVal pServerType$)
  llMinorRetVal = RegCloseKey(lhODBCKey)
  If (llRetVal = ERROR_SUCCESS) Then llRetVal = llMinorRetVal
  
  CreateODBCDataSource = llRetVal
End Function



' Creates an ODBC data source by manipulating the Registry
'
Public Function DeleteODBCDataSource(pDSN$) As Long

Dim llRetVal As Long, llMinorRetVal As Long
Dim lhODBCKey As Long
Dim lhOurKey As Long


  llRetVal = -1
  
  ' Validity checks
  DeleteODBCDataSource = llRetVal
  If False Then Exit Function
  
  
  ' Obtain a key to the ODBC sources list
  llRetVal = RegOpenKey(HKEY_CURRENT_USER, mODBCkeyName & "ODBC Data Sources", KEY_WRITE, lhODBCKey)
  If (llRetVal = ERROR_SUCCESS) Then
    llRetVal = RegDeleteValue(lhODBCKey, "", pDSN$)
    llMinorRetVal = RegCloseKey(lhODBCKey)
    If (llRetVal = ERROR_SUCCESS) Then llRetVal = llMinorRetVal
  End If
  
  ' Remove the description of our source
  llMinorRetVal = RegDeleteKey(HKEY_CURRENT_USER, mODBCkeyName & pDSN$)
  If (llRetVal = ERROR_SUCCESS) Then llRetVal = llMinorRetVal
  
  DeleteODBCDataSource = llRetVal
End Function

' Return a list of available ODBC SQL Server data sources
'
Public Sub ListODBCDataSources(pcolODBC As Collection)

Dim hKey As Long
Dim llRetVal As Long
Dim lpType As Long
Dim dwValueIndex As Long
Dim lpValueName As String
Dim lpValue As String


  EmptyCollection pcolODBC
  
  ' Open the key where they live.
  ' They're stored as entries with the value "SQL Server", and the key as the DSN
  llRetVal = RegOpenKey(HKEY_CURRENT_USER, mODBCkeyName & "ODBC Data Sources", KEY_READ, hKey)
  
  dwValueIndex = 0
  Do While (llRetVal = ERROR_SUCCESS)
    llRetVal = RegEnumValue(hKey, dwValueIndex, lpValueName, lpType, lpValue)

    If (llRetVal = ERROR_SUCCESS) Then
      If lpType = REG_SZ Then
        If (lpValue = "SQL Server") Then
          pcolODBC.Add Item:=lpValueName, Key:=lpValueName
        End If
      End If
      dwValueIndex = dwValueIndex + 1
    End If
  Loop
End Sub


' Return a list of available ODBC drivers
'
Public Sub ListODBCDrivers(pcolODBCDrivers As Collection)
 
Dim llRetVal As Long
Dim llIndex As Long
Dim lhKey As Long
Dim lServerTypeName$
Dim lServerTypeValue As Variant
Dim lpType As Long


  EmptyCollection pcolODBCDrivers
  
  llRetVal = RegOpenKey(HKEY_LOCAL_MACHINE, mODBCDriverkeyName & "ODBC Drivers", KEY_READ, lhKey)
  llIndex = 0
  If (llRetVal = ERROR_SUCCESS) Then llRetVal = RegEnumValue(lhKey, llIndex, lServerTypeName$, lpType, lServerTypeValue)
  Do While (llRetVal = ERROR_SUCCESS)
    If (lpType = REG_SZ) And (lServerTypeValue = "Installed") Then
      pcolODBCDrivers.Add Item:=lServerTypeName$, Key:=lServerTypeName$
    End If
    llIndex = llIndex + 1
    llRetVal = RegEnumValue(lhKey, llIndex, lServerTypeName$, lpType, lServerTypeValue)
  Loop
End Sub

' Return a list of available SQL Servers
'
Public Sub ListSQLServers(pcolServers As Collection)

Dim llRetVal As Long
Dim llIndex As Long
Dim lhKey As Long
Dim lServerName$
Dim lServerValue As Variant
Dim lpType As Long
Dim i%, lWork$


  EmptyCollection pcolServers
  
  llRetVal = RegOpenKey(HKEY_LOCAL_MACHINE, "Software\Microsoft\MSSQLServer\Client\PrefServers", KEY_READ, lhKey)
  llIndex = 0
  If (llRetVal = ERROR_SUCCESS) Then llRetVal = RegEnumValue(lhKey, llIndex, lServerName$, lpType, lServerValue)
  Do While (llRetVal = ERROR_SUCCESS)
    If (lpType = REG_SZ) And (IsNumeric(lServerName$)) Then
      i% = InStr(CStr(lServerValue), ",")
      If (i% > 0) Then
        lWork$ = left$(CStr(lServerValue), i% - 1)
        pcolServers.Add Item:=lWork$, Key:=lWork$
      End If
    End If
    llIndex = llIndex + 1
    llRetVal = RegEnumValue(lhKey, llIndex, lServerName$, lpType, lServerValue)
  Loop
End Sub


